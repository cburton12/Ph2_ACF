#include "PulseShape.h"

void PulseShape::Initialize()
{
  parseSetting();

  fShelve= fShelveVector[0];
  fBoard = fBoardVector[0];
  fFe    = fFeVector[0];
  uint32_t cFeId = fFe->getFeId();
  
  uint32_t cDelayAfterPulse = fBeBoardInterface->ReadBoardReg( cBoard, DELAY_AF_TEST_PULSE );
	      
  for ( auto& cCbc : fFe->fCbcVector )
    {
      uint32_t cCbcId = cCbc->getCbcId();
      
      // One canvas for each CBC
      TString cCanvasName = Form( "FE%dCBC%d  Online Canvas", cFeId, cCbcId );
      TCanvas* ctmpCanvas = new TCanvas( cCanvasName , cCanvasName );
      ctmpCanvas->Divide( 2, 1 );
      fCanvasMap[cCbc] = ctmpCanvas;

      // 2D histogram for the final plot, one per CBC
      uint32_t AmpRange = fAmpMax - fAmpMin;
      TString cHistName = Form( "Hist2D_Cbc%d" , cCbcId );
      TH2F* cAmpDel = new TH2F( cHistName , cHistName , AmpRange , fAmpMin , fAmpMax , 25 , 0 , 25 );
      cAmpDel->GetXaxis()->SetTitle( "Pulse Amplitude" );
      cAmpDel->GetYaxis()->SetTutle( "Pulse Delay" );
      f2DHistMap[cCbc] = cAmpDel;
      
      // Create graphs for each CBC 
      TString cName =  Form( "g_cbc_pulseshape_Fe%dCbc%d", cFeId, cCbcId );
      TObject* cObj = gROOT->FindObject( cName );
      if ( cObj ) delete cObj;
      TGraph* cPulseGraph = new TGraph();
      cPulseGraph->SetName( cName );
      cPulseGraph->SetMarkerStyle( 3 );
      cPulseGraph->GetXaxis()->SetTitle( "TestPulseDelay [ns]" );
      cPulseGraph->GetYaxis()->SetTitle( "TestPulseAmplitue [VCth]" );
      fPulseShapeMap[cCbc] = cPulseGraph;

    }     
}


void PulseShape::ScanTestPulseDelay(uint32_t cCoarseDelay)
{
  for (uint32_t cFineDelay = 0; cFineDelay < 25; cFineDelay++ )
    {
      uint32_t cDelay = cCoarseDelay + cFineDelay;
      setDelayAndTestGroup( cDelay );
      
      std::map< Cbc* , std::vector<uint32_t> > DelayRes;
      ScanTestPulseAmplitude(uint32_t cFineDelay);
    }
}

void PulseShape::ScanTestPulseAmplitude(uint32_t cFineDelay);
{
  for (uint32_t cAmp = fAmpMin; cAmp < fAmpMax; cAmp++)
    {
      setSystemTestPulse( cAmp , fChannel );
      vector1D VCthMid = ScanVCth(cFineDelay,cAmp);  // data taken here

      for (auto& cCbc : fFe->fCbcVector)
	{
	  uint8_t cCbcId = cCbc->getCbcId();
	  
	  auto cCanvas = fCanvasMap.find(cCbc)->second;
	  auto c2DHist = fHistMap.find(cCbc)->second;
	  auto cPulseShape = fPulseShapeMap.find(cCbc)->second;
	  
	  cPulseShape->Fill(cFineDelay , VCthMid[cCbcId] );
	  cCanvas->cd(2);
	  cPulseShape->Draw();
	  
	  c2DHist->Fill( cAmp , cFineDelay , VCthMid[cCbcId] );
	  cCanvas->cd(3);
	  c2DHist->Draw();
	  
	  cCanvas->Update();
	}
    }
}

vector1D PulseShape::ScanVcth(uint32_t cFineDelay , uint32_t cAmp)
{
  uint32_t cVCth = fVplus - 5 ;
  bool NZeros = 0;
  
  while (NZeros < 5)
    {
      CbcRegWriter cWriter( fCbcInterface, "VCth", cVCth );
      this->accept( cWriter );
      
      // then we take fNEvents
      vector2D EventData;
      uint32_t N = 0;
      uint32_t AcqNum = 0;

      fBeBoardInterface->Start( fBoard ); // start of data capture
      while (N < NumEvents )
	{
	  fBeBoardInterface->ReadData(fBoard,AcqNum,false);
	  const Event* cEvent = fBeBoardInterface->GetNextEvent(fBoard);
	  while (cEvent)
	    {
	      vector2D CbcData;
	      for (auto& cCbc : fFe->fCbcVector )
		{
		  uint32_t cCbcId = cCbc->getCbcId();
		  double result = cEvent->DataBit( 0 , cCbcId , fChannel);
		  CbcData.push_back(result);
		}
	      EventData.push_back(CbcData);
	      N++;
	      if (N <= NumEvents )
		cEvent = fBeBoardInterface->GetNextEvent(fBoard);
	      else break;
	    }
	  AcqNum++;
	}
      fBeBoardInterface->Stop( fBoard, AcqNum ); // end of data capture

      vector1D EventAvg = EventAveraging(EventData);
      ThresholdMap[cVCth] = EventAvg;
      cVCth++;
    }
  
  vector1D cMidPoints = MakeScurve(ThresholdRes,cFineDelay,cAmp,cVCth-1);
  return cMidPoints;
}


vector1D PulseShape::MakeScurve(vector1D ThresholdMap , uint32_t cFineDelay , uint32_t cAmp , uint32_t cVCthMax )
{
  vector1D cMidPoints;
  
  for (auto& cCbc : fFe->fCbcVector)
    {
      uint32_t cCbcId = cCbc->getCbcId();
      uint32_t cVCthMin = fVplus - 5;

      // Canvas recall
      auto cCanvas = fCanvasMap.find(cCbc)->second;

      // Scurve initialization
      TString cScurveName = Form("Scurve_Del%d_Amp%d" , cFineDelay , cAmp );
      TH1F* cScurve = dynamic_cast<TH1F*>( gROOT->FindObject(cScurveName) );
      if(cScurve) delete cScurve;
      cSCurve = new TH1F( cScurveName , cScurveName , cVCthMax - cVCthMin , cVCthMin , cVCthMax );
      cScurve->GetXaxis()->SetTitle("VCth");
      cScurve->GetYaxis()->SetTitle("Occupancy");

      // Fits
      TString cFitName = Form( "Fit_Del%d_Amp%d" , cFineDelay , cAmp );
      cFit = dynamic_cast<TF1*>( gROOT->FindObject(cFitName) );
      if (cFit) delete cFit;
      cFit = new TF1( cFitName , MyErf , 0 , 255 , 2 );

      // fill Scurves
      for (uint32_t cVCth = cVCthMin; cVCth < cVCthMax; cVCth++)
	  cScurve->Fill( cVCth , ThresholdMap.find(cVCth) );

      // Fit the Scurves
      double cFirstNon0( 0 );
      double cFirst1( 0 );
      
      for (int cBin = fScurve->GetNbinsX(); cBin>=1 ; cBin--) // not sure what this for loop does... taken from FASTCALIBRATION!
	{
	  double cContent = fScurve->GetBinContent( cBin );
	  if ( !cFirstNon0 )
	    {
	      if (cContent)
		cFirstNon0 = fScurve->GetBinCenter( cBin );
	    }
	  else if (cContent == 1)
	    {
	      cFirst1 = fScurve->GetBinCenter( cBin );
	      break;
	    }
	}
      
      double cMiddle = (cFirst1 + cFirstNon0 ) * 0.5;
      double cWidth  = (cFirst1 - cFirstNon0 ) * 0.5;
      cFit->SetParameter( 0 , cMiddle);
      cFit->SetParameter( 1 , cWidth );

      cScurve->Fit( cFit , "RNQ+" );

      // Drawing left panel
      cCanvas->cd(1);
      cScurve->Draw();
      cFit->Draw();
      
      // TEMPORARY SOLUTION: need to find the midpoint from the fit, not from the estimate
      cMidPoints.push_back(cMiddle);
      // ADD MIDPOINT FINDING CODE HERE...

      cCanvas->Update();
    }
  return cMidPoints;
}


vector1D PulseShape::EventAveraging(vector2D EventRes )
{
  vector1D EventAvg;
  for (cCbc : fFe->fCbcVector)
    {
      double sum = 0;
      for (ii=0; ii<NumEvents; ii++)
	sum += EventRes[ii][cCbc];
      EventAvg.push_back(sum/NumEvents);
    }
  return EventAvg;
}
 
int PulseShape::findTestGroup( uint32_t pChannelId )
{
  int cGrp = -1;
  for ( int cChIndex = 0; cChIndex < 16; cChIndex++ )
    {
      uint32_t cResult = pChannelId / 2 - cChIndex * 8;
      if ( cResult < 8 )
	cGrp = cResult;
    }
  return cGrp; 
}


void PulseShape::enableChannel( uint8_t pChannelId )
{
	std::string cReg = Form( "Channel%03d", pChannelId + 1 );;
	CbcRegWriter cWriter( fCbcInterface, cReg, fOffset );
	this->accept( cWriter );
}


void PulseShape::setDelayAndTesGroup( uint32_t pDelay )
{
  uint8_t cCoarseDelay = floor( pDelay  / 25 );
  uint8_t cFineDelay = ( cCoarseDelay * 25 ) + 24 - pDelay;
  
  std::cout << "cFineDelay: " << +cFineDelay << std::endl;
  std::cout << "cCoarseDelay: " << +cCoarseDelay << std::endl;
  std::cout << "Current Time: " << +pDelay << std::endl;
  BeBoardRegWriter cBeBoardWriter( fBeBoardInterface, DELAY_AF_TEST_PULSE, cCoarseDelay );
  this->accept( cBeBoardWriter );
  CbcRegWriter cWriter( fCbcInterface, "SelTestPulseDel&ChanGroup", to_reg( cFineDelay, fTestGroup ) );
  this->accept( cWriter );
}


void PulseShape::parseSettings()
{
  // now read the settings from the map
  auto cSetting = fSettingsMap.find( "Nevents" );
  if ( cSetting != std::end( fSettingsMap ) ) fNevents = cSetting->second;
  else fNevents = 2000;
  cSetting = fSettingsMap.find( "HoleMode" );
  if ( cSetting != std::end( fSettingsMap ) )  fHoleMode = cSetting->second;
  else fHoleMode = 1;
  cSetting = fSettingsMap.find( "Vplus" );
  if ( cSetting != std::end( fSettingsMap ) )  fVplus = cSetting->second;
  else fVplus = 0x6F;
  cSetting = fSettingsMap.find( "TPAmplitude" );
  if ( cSetting != std::end( fSettingsMap ) ) fTPAmplitude = cSetting->second;
  else fTPAmplitude = 0x78;
  cSetting = fSettingsMap.find( "ChannelOffset" );
  if ( cSetting != std::end( fSettingsMap ) ) fOffset = cSetting->second;
  else fOffset = 0x05;
  cSetting = fSettingsMap.find( "Channel" );
  if ( cSetting != std::end( fSettingsMap ) ) fChannel = cSetting->second;
  else fChannel = 9;
  cSetting = fSettingsMap.find( "StepSize" );
  if ( cSetting != std::end( fSettingsMap ) ) fStepSize = cSetting->second;
  else fStepSize = 5;

  std::cout << "Parsed the following settings:" << std::endl;
  std::cout << "	Nevents    = " << fNevents << std::endl;
  std::cout << "	HoleMode   = " << int( fHoleMode ) << std::endl;
  std::cout << "	Vplus      = " << int( fVplus ) << std::endl;
  std::cout << "	TPAmplitude= " << int( fTPAmplitude ) << std::endl;
  std::cout << "	Channel    = " << int( fChannel ) << std::endl;
  std::cout << "	StepSize   = " << int( fStepSize ) << std::endl;
  
}


void PulseShape::setSystemTestPulse( uint8_t pTPAmplitude, uint8_t pChannelId )
{
  // translate the channel id to a test group
  std::vector<std::pair<std::string, uint8_t>> cRegVec;
  
  //calculate the right test group
  this->fTestGroup = findTestGroup( pChannelId );
  
  uint8_t cRegValue =  to_reg( 0, fTestGroup );
  cRegVec.push_back( std::make_pair( "SelTestPulseDel&ChanGroup",  cRegValue ) );
  
  //set the value of test pulsepot registrer and MiscTestPulseCtrl&AnalogMux register
  if ( fHoleMode )
    cRegVec.push_back( std::make_pair( "MiscTestPulseCtrl&AnalogMux", 0xD1 ) );
  else
    cRegVec.push_back( std::make_pair( "MiscTestPulseCtrl&AnalogMux ", 0x61 ) );
  
  cRegVec.push_back( std::make_pair( "TestPulsePot", pTPAmplitude ) );
  cRegVec.push_back( std::make_pair( "Vplus",  fVplus ) );
  
  CbcMultiRegWriter cWriter( fCbcInterface, cRegVec );
  this->accept( cWriter );

  uint32_t cFeId = cFe->getFeId();
  for ( auto& cCbc : cFe->fCbcVector )
    {
      uint32_t cCbcId = cCbc->getCbcId();
      Channel* cChannel = new Channel( cBoardId, cFeId, cCbcId, pChannelId );
      fChannelMap[cCbc] = cChannel;    
    }
  // enableChannel( pChannelId );
  std::cout << "Channel: " << +pChannelId << std::endl;
}


double pulseshape( double* x, double* par )
{
  double xx = x[0];
  double temp = pow( ( xx - par[1] ) / par[2] , 3 );
  double val = ( ( par[0] * temp * exp( -( ( xx - par[1] ) / par[2] ) ) ) ) + par[3];
  if ( xx < par[1] )
    val = par[3];
  return val;
}


